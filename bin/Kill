#!/bin/sh
#
# Copyright (c) 2008 by Bruce Blinn
#
# NAME
#	Kill - kill a process (send a signal) by name
#
# SYNOPSIS
#	Kill [-signal | -s signal] processName
#
# DESCRIPTION
#	This command will send a signal to any process with the
#	specified name.  For each process that is found, the user
#	will be asked for confirmation before sending the signal to
#	the process.
#
# OPTIONS
#	-signal or -s signal
#		This option specifies the signal to send to the
#		process(es).  Either the signal number or the signal
#		name may be used.  For example:
#
#			Kill -s 9 processName
#			Kill -s SIGKILL processName
#			Kill -9 processName
#			Kill -SIGKILL processName
#
#		If this option is not specified, SIGTERM will be
#		sent to the process(es).
#
# RETURN VALUE
#	0	Successful completion.  It is not an error if the
#		process is not found.
#
#	1	Error - see the message written to standard error.
#
####################################################################
CMDNAME=`basename $0`
USAGE="Usage: $CMDNAME [-signal] ProcessName"
SIGNAL=			# Signal option for the kill(1) command.
NAME=			# Name of process to kill.
PID=			# PID of process being checked.
OWNER=			# Owner of process being checked.
PATH=$PATH:`dirname $0`
OLD_IFS=$IFS		# Original value of IFS variable
PROCNAME=		# Name of process being checked
PS_OPTS=		# Options for ps command
PROCESS_LIST=/tmp/list.$$ # Output of ps command
TITLE_PRINTED=FALSE	# Title printed? (TRUE or FALSE)
FOUND=FALSE		# Found matching process?
LINE=			# Single line of output from ps
COL=			# Column where process name begins
SYSTEM=`SystemType`	# String identifying the system

. SystemType.sh
. GetYesNo.sh

trap 'rm -f /tmp/*.$$; exit 1' 1 2 3 15

#
# Get and check the command line parameters.
#
case $1 in
	--)	shift
		;;
	-*)	SIGNAL=$1	 # Leave the hyphen
		shift
		;;
esac
if [ $# -ne 1 ]; then
	echo "$USAGE" 1>&2
	exit 1
fi

NAME=$1        # Get the name of the process to kill.

#
# Determine which options to use with the ps command.
#
case $SYSTEM in
	SUNBSD | ULTRIX )	PS_OPTS="-auxw"	;;
	* )			PS_OPTS="-efw"	;;
esac

#
# Get a list of the current processes and filter out the
# lines that do not contain the process we are looking for.
#
ps $PS_OPTS			|
	sed '1d'		|	# Remove the title line
	grep "$NAME"		|	# Eliminate the chaff
	grep -v "$0"		|	# Eliminate this process
	grep -v "ps $PS_OPTS"	>$PROCESS_LIST

#
# Check each process.
#
exec <$PROCESS_LIST
IFS=
while read LINE
do
	IFS=$OLD_IFS
	#
	# Get the owner, PID, and name of the process.
	#
	set $LINE
	OWNER=$1
	PID=$2

	#
	# Determine the column where the process name begins.
	#
	case $SYSTEM in
		LINUX )				COL=49 ;;
		AIX | HP | SGI | SOLARIS )	COL=48 ;;
		SUNBSD | DECOSF )		COL=57 ;;
		ULTRIX )			COL=51 ;;
		* )	echo "Unexpected system type." 1>&2
			exit 1
			;;
	esac

	LINE=`echo "$LINE" | cut -c$COL-`
	set dummy $LINE
	shift
	PROCNAME=$1

	if [ "$PROCNAME" = "$NAME" -o \
		"`basename $PROCNAME`" = "$NAME" ]; then

		FOUND=TRUE

		#
		# Print title.
		#
		if [ "$TITLE_PRINTED" = "FALSE" ]; then
			echo "PID	Owner	Process"
			TITLE_PRINTED=TRUE
		fi

		#
		# Ask user.
		#
		if GetYesNo \
			"$PID	$OWNER	$PROCNAME (y/n)? " </dev/tty
		then
			kill $SIGNAL $PID
		fi
	fi
	IFS=
done

if [ "$FOUND" = "FALSE" ]; then
	echo "Process \"$NAME\" not found."
fi

rm -f /tmp/*.$$
exit 0
