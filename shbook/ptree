#!/bin/sh
#
# Copyright (c) 2008 by Bruce Blinn
#
# NAME
#	ptree - print a process tree
#
# SYNOPSIS
#	ptree [-v][-k | -signal | -s signal] processID [level mypid]
#
# DESCRIPTION
#	This command will print the process tree for the specified
#	process.
#
#	NOTE: The level and mypid parameters should not be used.
#	They are only used when this command calls itself
#	recursively to print the next level of the process tree.
#
# OPTIONS
#	-k	Kill the processes.  That is, send the SIGTERM
#		signal to each process after it is printed.
#
#	-signal or -s signal
#		Send the specified signal to each process after it
#		is printed.  Either the signal number or the signal
#		name may be used.  For example:
#
#			ptree -s 9 processID
#			ptree -s SIGKILL processID
#			ptree -9 processID
#			ptree -SIGKILL processID
#
#		If this option is not specified, no signal will be
#		sent to the process(es).
#
#	-v	Verbose.
#
# RETURN VALUE
#	0	Successful completion.
#	1	Error - see the message written to standard error.
#
####################################################################
CMDNAME=`basename $0`
USAGE="Usage: $CMDNAME [-n] [pid]"
PID=			# PID of the starting process.
LEVEL=			# Indentation level (num parents).
INDENT=			# Column number where line begins.
LINE=			# Line of output.
NAME=			# Name of the process.
PATH=$PATH:`dirname $0`
RECURSIVE=TRUE		# List processes recursively
PROCESS=		# PID of the starting process
DATAFILE=		# Reformatted output from ps
PSFILE=/tmp/ps.$$	# Output from the ps command
PS_OPTS=		# Options for the ps command
OLD_IFS=$IFS		# Original value of IFS variable
SYSTEM=`SystemType`	# String identifying the system

#
# Temporaries
#
PPID=			# Process ID of the parent process
OWNER=			# Owner of the process
OUTLINE=		# Line of output

. SystemType.sh

trap 'rm -f /tmp/*.$$; exit 1' 1 2 3 15

FillLine() {
	#
	# SYNOPSIS
	#	FillLine line column
	#
	_LINE="$1"
	_COLUMN=$2
	_LEN=`expr "$_LINE" : '.*'`
	while [ $_LEN -lt $_COLUMN ]
	do
		_LINE="$_LINE "
		_COLUMN=`expr $_COLUMN - 1`
	done

	echo "$_LINE"
}

while :
do
	case $1 in
		-n)	RECURSIVE=FALSE
			shift
			;;
		--)	shift
			break
			;;
		-*)	echo "$USAGE" 1>&2
			exit 1
			;;
		*)	break
			;;
	esac
done

#
# Make sure the number of parameters is reasonable.
#
if [ $# -eq 0 ]; then
	PROCESS=1
	LEVEL=0
	DATAFILE=/tmp/ptree.$$
elif [ $# -eq 1 ]; then
	PROCESS=$1
	LEVEL=0
	DATAFILE=/tmp/ptree.$$
elif [ $# -eq 3 ]; then
	PROCESS=$1
	LEVEL=$2
	DATAFILE=$3
else
	echo "$USAGE" 1>&2
	exit 1
fi

if [ "$LEVEL" = 0 ]; then
	#
	# Determine which options to use with the ps command.
	#
	case $SYSTEM in
		SUNBSD | ULTRIX )	PS_OPTS="-auwx"	;;
		* )			PS_OPTS="-ef"	;;
	esac

	#
	# Build the data file.
	#
	rm -f $DATAFILE $PSFILE
	ps -ef | sed '1d' | sort >$PSFILE

	exec <$PSFILE
	IFS=
	while read LINE
	do
		IFS=$OLD_IFS

		set $LINE
		OWNER=$1
		PID=$2
		PPID=$3

		#
		# Determine column where the process name begins.
		#
		case $SYSTEM in
			AIX | HP | SGI | SOLARIS )	COL=48 ;;
			SUNBSD | DECOSF )		COL=57 ;;
			ULTRIX )			COL=51 ;;
			* )	echo "Unexpected system type." 1>&2
				exit 1
				;;
		esac

		LINE=`echo "$LINE" | cut -c$COL-`
		set dummy $LINE
		shift
		NAME=$1

		echo $PID $PPID $OWNER $NAME >>$DATAFILE
		IFS=
	done
	IFS=$OLD_IFS
fi

INDENT=`expr $LEVEL \* 2`
OUTLINE=`FillLine "" $INDENT`

LINE=`grep "^$PROCESS " $DATAFILE`
set $LINE
OUTLINE="$OUTLINE  $1"
OUTLINE=`FillLine "$OUTLINE" 30`
OUTLINE="$OUTLINE  $3	$4"
echo "$OUTLINE"

#
# Print the current process.
#
if [ "$RECURSIVE" = "TRUE" ];then
	LEVEL=`expr $LEVEL + 1`
	while read LINE
	do
		set $LINE
	#
	# For every process that is a child of the current process,
	# invoke this command ($0) recursively.
	#
		if [ "$2" = "$PROCESS" ]; then
			$0 $1 $LEVEL $DATAFILE
		fi
	done <$DATAFILE
fi

rm -f /tmp/*.$$
exit 0
